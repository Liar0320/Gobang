给chessboard绑定点击事件;

因为我们的棋盘式根据宽度来保持横纵比的，所以每一个网格的大小在不同分辨率下是不一样的。因此对应的棋子大小也应自适应。
//获取canvas大小，根据640的宽度进行等比缩放。缩放对象为棋盘（棋盘大小为600*600）和棋子（35*35）;                 ----------- chessinit
获取chessboard大小，因为宽度自适应所以高度 = 宽度 赋值操作 保持棋盘大小一致，根据600的宽度进行等比缩放。棋子（35*35），实际棋盘（275*375），棋盘的留白（25*25）;
进行抽象棋盘的计算。
	棋盘大小 行0-14 列0-14。共有225个交叉点;
	turn = 1 为白色 2 为黑色;
	棋盘配置booardOptions；
		是否开启落子前提示。
		是否开启计时器。
	abstractBoard.containt =	[(0,0),(1,0  ),(2,0 ),(3,0 ).....(14,0 )]     ---->[status] status = 0为没有棋子，1为白色，2为黑色，3为选中（落子之前的提示）。
								[(0,1),(1,1  ),(2,1 ),(3,1 ).....(14,1 )] 										
								[................................(..,14)]
								[(0,14),(1,14),(2,14),(3,14).....(14,14)] 
	abstractBoard.boardCell = abstractBoard.size/15;
	//boardCell = abstractBoard.size/15;
	进行落子位置的计算。获取鼠标点击的位置，减去棋盘的留白，Math.round(x/boardCell);Math.round(y/boardCell);
	获取二维坐标(rx,ry),如果该坐标为空（0）则置为选中（3），如果该坐标为选中（3）则置为当前选手(turn) ,缓存棋子位置 histroyStep.push((rx,ry)),则上一个棋子位置（prevCell）棋子位置 = histroyStep.last()。
	进行五子棋胜负逻辑运算 如果成立返回true ， 游戏结束。																---- valid
						   如果失败返回false， 进行选手的轮换。如果有计时，计时重新开始。

	
	游戏之外的控制
		计时时间到轮换选手，计时重新开始。（也可以默认选手操作为空）。
		悔棋成功。（将缓存棋子的数组抛出一个（histroyStep.pop()）,然后将该抛出的二维坐标置空（0）,则上一个棋子位置（prevCell）棋子位置 = histroyStep.last()，【进行选手的轮换。如果有计时，计时重新开始 （即逻辑运算失败的操作）】）。
		认输（选手轮换 胜利方法）。

	定义一个serverCtrls用来 修改游戏的控制，
	
	游戏的状态
		登录界面
		主界面
		游戏等待界面
		游戏进行界面
		游戏结束界面


	